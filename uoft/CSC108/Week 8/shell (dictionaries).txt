Python 2.7.2 (v2.7.2:8527427914a2, Jun 11 2011, 14:13:39) 
[GCC 4.0.1 (Apple Inc. build 5493)]
Type "help", "copyright", "credits" or "license" for more information.
>>> emissions_by_year = {1799: 1, 1800: 70, 1801: 74, 1802: 82, 1902: 215630, 2002: 1733297}
>>> emissions_by_year[1902]
215630
>>> emissions_by_year[1799] = 2
>>> emissions_by_year
{1799: 2, 1800: 70, 1801: 74, 1802: 82, 1902: 215630, 2002: 1733297}
>>> emissions_by_year[1803] = 100
>>> emissions_by_year
{1799: 2, 1800: 70, 1801: 74, 1802: 82, 1803: 100, 1902: 215630, 2002: 1733297}

>>> # Keys don't have to be numbers, but they have to be immutable.
>>> d = {1:5, 3:45, 4:10}
>>> d[[1, 2, 3]] = 100    # error
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
TypeError: unhashable type: 'list'
>>> d[(1, 2, 3)] = 100   # tuples are immutable, so this is fine.
>>> d
{1: 5, 3: 45, 4: 10, (1, 2, 3): 100}

>>> # values can be any type, mutable or not
>>> d[5] = ["Diane", "Paul", "Karen"]
>>> d['weird'] = ['hello', 'bye']
>>> d['nested'] = {'diane':4236, 'paul':4234}
>>> d
{1: 5, 3: 45, 4: 10, 5: ['Diane', 'Paul', 'Karen'], (1, 2, 3): 100, 'weird': ['hello', 'bye'], 'nested': {'paul': 4234, 'diane': 4236}}
>>> d['nested']
{'paul': 4234, 'diane': 4236}
>>> d['nested']['paul']
4234

>>> # type dict is mutable
>>> id(d)
17224304
>>> d['me'] = 'you'
>>> id(d)
17224304

>>> emissions_by_year
{1799: 2, 1800: 70, 1801: 74, 1802: 82, 1803: 100, 1902: 215630, 2002: 1733297}
>>> # extend
emissions_by_year[2009] = 1000000
>>> # update
emissions_by_year[2002] = 10
>>> # check for membership
>>> 1950 in emissions_by_year
False
>>> 2002 in emissions_by_year
True
>>> # remove a key-value pair
>>> del emissions_by_year[1803]
>>> 1803 in emissions_by_year
False
>>> # determine length
>>> len(emissions_by_year)
7
>>> # iterate over a dict
for key in emissions_by_year:
	print key

1799
1800
1801
1802
1902
2002
2009

>>> for key in d:
	print key

me
1
3
4
5
(1, 2, 3)
weird
nested
>>> # Dictionaries are unordered.  The order that the keys
>>> # are traversed is arbitrary: no guarantee that it 
>>> # will be the order that they were added to it.

>>> for key in emissions_by_year:
	print emissions_by_year[key]

2
70
74
82
215630
10
1000000

>>> # Methods
>>> dir(dict)
['__class__', '__cmp__', '__contains__', '__delattr__', '__delitem__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'has_key', 'items', 'iteritems', 'iterkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values', 'viewitems', 'viewkeys', 'viewvalues']
>>> # keys
>>> emissions_by_year.keys()
[1799, 1800, 1801, 1802, 1902, 2002, 2009]
>>> # values
>>> emissions_by_year.values()
[2, 70, 74, 82, 215630, 10, 1000000]
>>> # items: the (key, value) pairs as a list of tuples
>>> emissions_by_year.items()
[(1799, 2), (1800, 70), (1801, 74), (1802, 82), (1902, 215630), (2002, 10), (2009, 1000000)]
>>> empty_dict = {}
>>> empty_dict.keys()
[]
>>> empty_dict.values()
[]
>>> empty_dict.items()
[]
>>> # get
>>> emissions_by_year.get(1802)
82
>>> emissions_by_year.get(1805)
>>> print emissions_by_year.get(1805)
None
>>> emissions_by_year[1805]
Traceback (most recent call last):
  File "<string>", line 1, in <fragment>
KeyError: 1805
>>> emissions_by_year.get(1805)
>>> emissions_by_year.get(1805, -1)  # asking to get -1 return if key not there
-1
>>> emissions_by_year.get(1805, "not there")
'not there'

>>> # update
>>> dict1 = {'978-6025': 'Diane', '978-3965' : 'Tom'}
>>> dict2 = {'978-6360' : 'UG office', '978-6025' : 'main office'}
>>> dict1.update(dict2)  # add dict2 contents to dict1; updates keys from dict1 with key-value pairs from dict2
>>> dict1
{'978-6025': 'main office', '978-3965': 'Tom', '978-6360': 'UG office'}
>>> help(dict.update)
Help on method_descriptor:

update(...)
    D.update(E, **F) -> None.  Update D from dict/iterable E and F.
    If E has a .keys() method, does:     for k in E: D[k] = E[k]
    If E lacks .keys() method, does:     for (k, v) in E: D[k] = v
    In either case, this is followed by: for k in F: D[k] = F[k]

>>> d1 = {1:1, 2:2}
>>> d2 = {2: 222, 3:3}
>>> d1.update(d2)
>>> d1
{1: 1, 2: 222, 3: 3}
>>> d2
{2: 222, 3: 3}
>>> # clear
>>> d2.clear()
>>> d2
{}

# Iterating over keys, values, items
>>> phone = {'555-7632' : 'Paul', '555-9999' : 'Andrew', '555-1111' : 'Dan', '555-2222' : 'Michael', '555-3333': 'Karen'} 

>>> # The proper way:
>>> for key in phone:
	print key

555-7632
555-9999
555-3333
555-2222
555-1111

>>> # The equivalent, but not considered good style.
>>> for key in phone.keys():
	print key

555-7632
555-9999
555-3333
555-2222
555-1111

>>> for value in phone.values():
	print value

Paul
Andrew
Karen
Michael
Dan

>>> for item in phone.items():
	print item

('555-7632', 'Paul')
('555-9999', 'Andrew')
('555-3333', 'Karen')
('555-2222', 'Michael')
('555-1111', 'Dan')

>>> # You can pull the pieces of the tuple out as you go:
>>> for (number, name) in phone.items():
	print "Name: %s; Phone number: %s" % (name, number)

Name: Paul; Phone number: 555-7632
Name: Andrew; Phone number: 555-9999
Name: Karen; Phone number: 555-3333
Name: Michael; Phone number: 555-2222
Name: Dan; Phone number: 555-1111
>>> x = 4
>>> y = 3.4
>>> print 'hello %d, by %f' % (x, y)
hello 4, by 3.400000
>>> print 'hello ' + str(x) + ', by ' + str(y)
hello 4, by 3.4