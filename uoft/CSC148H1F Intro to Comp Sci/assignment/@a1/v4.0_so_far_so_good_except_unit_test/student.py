# Assignment 1 - Managing Students!## CSC148 Fall 2014, University of Toronto# Instructor: David Liu# ---------------------------------------------# STUDENT INFORMATION## List your group members below, one per line, in format# <full name>, <utorid># Su Young Lee, leesu9# Rui Qiu, qiurui2## ---------------------------------------------"""The back-end data model for the program."""from error_class import *def object_caller(name, target_list):    ''' (str, list of Classes) -> (boolean, object)    Return whether object is in target list, and the object itself)    (If object was not in the list, then returns (False, None))    Very important helper function.    *Necessary* to find the relevant student/course class in the School lists.    Parameters:    - name: The name of the object that's being searched for    - target_list: The target list containing various classes    '''    for object in target_list:        if object.name == name:            return True, object    return False, Nonedef natural_number_checker(maybe_number):    ''' (object) -> (boolean)    Return whether object is a natural number (not including 0)    Parameters:    - maybe_number: What's tested to see whether it's a natural number or not.     Could be a str as well.    '''    try:        int_number = int(maybe_number)        if int_number > 0:            return True    # only occurs if not integer.    except (ValueError, TypeError) as e:        return Falseclass EmptyStackError(Exception):    pass
class Stack:    def __init__(self):        self.command_stack = []    def push(self, item):        self.command_stack.append(item)    def pop(self):        try:
            x = self.command_stack.pop()            return x
        except IndexError:            raise EmptyStackError
    def is_empty(self):
        return len(self.command_stack) == 0class School:    '''A school, with given students, and courses.    This class contains the undo stack, and is the the main class    that keeps all of the student and course classes.    All of the methods in this class are used to check that the    command input is valid and applicable, and then calls the    relevant function in a given class (student/course).    If the command doesn't work, then error messages are raised.    Attributes:    - self.name (str): The name of the school.  Largely aesthetic,      but allows future implementation for multiple schools    - self.student_list (list of Student): Contains a list of Student objects.    - self.course_list (list of Course): Contains a list of Course objects.    - self.undo_stack (Stack): Contains record of commands in order to undo    The undo stack can contain the following:    1: This means the last command was invalid/inapplicable.    ('create', student_name, course_name): Command was student creation.    ('drop', student_name, course_name): Command was student dropping a course.    ('enrol', student_name, course_name): Command was student enroling.    undo_it(): Reverses the last command (if valid).    The undo function is the only function in the School class that is not    either used as a helper function, or used to call other functions.    '''    def __init__(self, name):        self.name = name        self.student_list = []        self.course_list = []        self.undo_stack = Stack()    def student_create(self, name):        ''' (School, str) -> NoneType        Create student with name.        Print error if student exists.        Parameters:        - name: name of the student to be made.        '''        # Below is the object_caller function.        # It will be used A LOT, so understand what it does.        # Here, it's being used in the same fashion as:        #    if name in student_list:        if object_caller(name, self.student_list)[0]:            self.undo_stack.push(1)            raise StudentAlreadyExistsError(name)        # Command was successful        else:            self.undo_stack.push(('create', name))            x = Student(name)            self.student_list.append(x)    def course_drop(self, name, course):        ''' (School, str, str) -> NoneType        Call Student.course_drop and Course.student_removal if cmd successful        Parameters:        - name: name of student dropping the course        - course: course name being dropped.        '''        if not (object_caller(name, self.student_list)[0]):            self.undo_stack.push(1)            raise StudentNotExistError(name)        else:            target_student = object_caller(name, self.student_list)[1]            if not (course in target_student.course_list):                self.undo_stack.push(1)            # Command was successful            else:                target_course = object_caller(course, self.course_list)[1]                target_student.course_drop(course)                target_course.student_removal(name)                self.undo_stack.push(('drop', name, course))    def common_check(self, name1, name2):        ''' (School, str, str) -> NoneType        Call Student.common_check if command was successful        Parameters:        - name1: Name of first student        - name2: Name of second student        '''        # This is done first, because it will happen no matter what anyway.        self.undo_stack.push(1)        s1_exists = object_caller(name1, self.student_list)[0]        s2_exists = object_caller(name2, self.student_list)[0]        if not s1_exists and not s2_exists:            raise BothStudentsNotExistError        if not s1_exists:            raise StudentNotExistError(name1)        if not s2_exists:            raise Student2NotExistError        # Verifies that both students exist.        elif (object_caller(name1, self.student_list)[0]):            student1 = object_caller(name1, self.student_list)[1]            student2 = object_caller(name2, self.student_list)[1]            student1.common_check(student2)    def list_courses(self, name):        ''' (School, str) -> NoneType        Call Student.list_courses if command was successful        Parameters:        - name: Name of target student        '''        self.undo_stack.push(1)        exists, student = object_caller(name, self.student_list)        # if student doesn't exist.        if not exists:            raise StudentNotExistError(name)        else:            if len(student.course_list) == 0:                print ('{0} is not taking any courses.'.format(name))            else:                student.list_courses()    def enrol_student(self, student_name, course_name):        ''' (School, str, str) -> NoneType        Call Student.enrol_class and Course.student_addition        (if command was successful)        Parameters:        - student_name: Name of enrolling student        - course_name: Name of course to be enrolled into.        '''        s_exists, student = object_caller(student_name, self.student_list)        c_exists, course = object_caller(course_name, self.course_list)        if not s_exists:            self.undo_stack.push(1)            raise StudentNotExistError(student_name)        # If the course doesn't exist yet, it must be made.        elif not c_exists:            self.new_class_creation(student, course_name)            self.undo_stack.push(('enrol', student_name, course_name))        # The consequent elif + else are only if student exists + course exists        elif len(course.student_list) >= 30:            self.undo_stack.push(1)            raise FullCourseError(course.name)        elif course_name in student.course_list:            self.undo_stack.push(1)        # When course and student exist, and course <30        else:            student.enrol_class(course)            course.student_addition(student.name)            self.undo_stack.push(('enrol', student_name, course_name))    def new_class_creation(self, student, course_name):        ''' (School, Student, str) -> NoneType        Create a new course, and enrol student into it.        Parameters:        - student: The student to be enrolled in the new course.        - course_name: Name of the new course to be made.        '''        new_class = Course(course_name, student.name)        self.course_list.append(new_class)        student.enrol_class(new_class)    def class_list(self, course_name):        ''' (School, str) -> NoneType        Call Course.class_list if course exists        Parameters:        - course_name: Name of the target course        '''        self.undo_stack.push(1)        course_exists, course = object_caller(course_name, self.course_list)        if course_exists:            course.class_list()        else:            # course does not exist.  But we say this anyway...            print ('No one is taking ' + course_name + '.')    def undo_once(self):        ''' (School) -> NoneType        Remove last item in queue        Call undo_it if last item was a tuple        '''        try:            undo_variable = self.undo_stack.pop()            if type(undo_variable) == tuple:                self.undo_it(undo_variable)        except EmptyStackError:            raise NoCommandsUndoError    def undo_it(self, undo_tuple):        ''' (School, tuple) -> NoneType        Undo the relevant command        Parameters:        - undo_tuple: The tuple which says which command to undo          (create/enrol/drop) and has course/student info        '''        if undo_tuple[0] == 'create':            name = undo_tuple[1]            poor_student = object_caller(name, self.student_list)[1]            self.student_list.remove(poor_student)        elif undo_tuple[0] == 'enrol':            name, course = undo_tuple[1], undo_tuple[2]            target_student = object_caller(name, self.student_list)[1]            target_course = object_caller(course, self.course_list)[1]            target_student.course_drop(course)            target_course.student_removal(name)        elif undo_tuple[0] == 'drop':            student_name, course_name = undo_tuple[1], undo_tuple[2]            student = object_caller(student_name, self.student_list)[1]            course = object_caller(course_name, self.course_list)[1]            student.enrol_class(course)            course.student_addition(student.name)        else:            print ("Something went horribly wrong.")    def undo_repeat(self, repeats):        ''' (School, object) -> NoneType        Repeat undo function (repeats) times, if (repeats) is a natural number        Parameters:        - repeats: The (maybe) natural number used to determine how many undos.        '''        if natural_number_checker(repeats):            repeats = int(repeats)            for x in range(0, repeats):                try:                    undo_variable = self.undo_stack.pop()                    if type(undo_variable) == tuple:                        self.undo_it(undo_variable)                except EmptyStackError:                    raise NoCommandsUndoError        else:            self.undo_stack.push(1)            raise NotNaturalNumberUndoError(repeats)
class Student:    '''A student in a given school.    As all error conditions are handled in the School class,    all methods called in the Student class assumes that the command was valid,    and should work (hence the simplicity).    All methods in the student class manipulate/use the courses    pertaining to the given student object.    Attributes:    - self.name (str): Name of the student.      Important, used to identify the student object in the school class.    - self.course_list (list of str): List of courses for given student.    '''
    def __init__(self, name):
        self.name = name        self.course_list = []    def course_drop(self, course):        ''' (Student, str) -> NoneType        Remove course from student's course list        Parameters:        - course: The name of the course to be dropped        '''        self.course_list.remove(course)    def common_check(self, other_student):        ''' (Student, Student) -> NoneType        Print common courses between the two students        Parameters:        - other_student: the other student who's courses are compared        '''        common_list = []        for course in self.course_list:            if course in other_student.course_list:                common_list.append(course)        if len(common_list) >= 1:            common_list.sort()            print (', '.join(common_list))        else:            print ()    def list_courses(self):        ''' (Student) -> NoneType        Print the courses the student is taking.        '''        self.course_list.sort()        printstr = ', '.join(self.course_list)        print ('{0} is taking {1}'.format((self.name), printstr))    def enrol_class(self, target_class):        ''' (Student, Class) -> NoneType        Append course to student's course list        Parameters:        - target_class: course to append to course list.        '''        self.course_list.append(target_class.name)
class Course:    '''A course in a given school.    As all error conditions are handled in the School class,    all methods called in the Course class assumes that the command was valid,    and should work (hence the simplicity).    All methods in the Course class manipulate/use    the students pertaining to the given Course object.    Attributes:    - self.name (str): Name of the Course.      Important, used to identify the Course object in the school class.    - self.student_list (list of str): List of students for given course.    '''    def __init__(self, name, student):        self.name = name        self.student_list = [student]    def student_removal(self, student_name):        ''' (Course, str) -> NoneType        Remove student from course's student list        Parameters:        - student_name: Name of the student to be removed from course        '''        self.student_list.remove(student_name)    def student_addition(self, student_name):        ''' (Course, str) -> NoneType        Add student to course's student list        Parameters:        - student_name: Name of student to be added to course        '''        self.student_list.append(student_name)    def class_list(self):        ''' (Course) -> NoneType        Print list of students taking the given courses        '''        if len(self.student_list) == 0:            print('No one is taking {0}.'.format(self.name))        else:            self.student_list.sort()            print (', '.join(self.student_list))