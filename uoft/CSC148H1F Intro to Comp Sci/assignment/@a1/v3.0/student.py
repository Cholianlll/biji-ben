class EmptyStackError(Exception):    pass
class Stack:    def __init__(self):        self.command_stack = []
    def push(self, item):        self.command_stack.append(item)
    def pop(self):
        try:
            x = self.command_stack.pop()            return x
        except IndexError:
            raise EmptyStackError
    def is_empty(self):
        return len(self.command_stack) == 0
class School:
    def __init__(self, name):
        self.name = name
        self.student_list = []
        self.course_list = []
        self.undo_stack = Stack()    def student_create(self, name):        if object_caller(name, self.student_list)[0]:            print ("ERROR: Student", name, "already exists.")            self.undo_stack.push(1)        else:            self.undo_stack.push(('create', name))            x = Student(name)            self.student_list.append(x)    def course_drop(self, name, course):        if not (object_caller(name, self.student_list)[0]):            print ("ERROR: Student", name, "does not exist.")            self.undo_stack.push(1)        else:            target_student = object_caller(name, self.student_list)[1]            if not (course in target_student.course_list):                self.undo_stack.push(1)            else:                target_course = object_caller(course, self.course_list)[1]                target_student.course_drop(course)                target_course.student_removal(name)                self.undo_stack.push(('drop', name, course))    def common_check(self, name1, name2):        # This is done first, because it will happen no matter what anyway.        self.undo_stack.push(1)        if not (object_caller(name1, self.student_list)[0]):            print ("ERROR: Student", name1, "does not exist.")        if not (object_caller(name2, self.student_list)[0]):            print ("ERROR: Student", name2, "does not exist.")        # Verifies that both students exist.        elif (object_caller(name1, self.student_list)[0]):            student1 = object_caller(name1, self.student_list)[1]            student2 = object_caller(name2, self.student_list)[1]            student1.common_check(student2)    def list_courses(self, name):        self.undo_stack.push(1)        exists, student = object_caller(name, self.student_list)        # if student doesn't exist.        if not exists:            print ('ERROR: Student {0} does not exist.'.format(name))        else:            if len(student.course_list) == 0:                print ('{0} is not taking any courses.'.format(name))            else:                student.list_courses()    def enrol_student(self, student_name, course_name):        s_exists, student = object_caller(student_name, self.student_list)        c_exists, course = object_caller(course_name, self.course_list)        if not s_exists:            print ('ERROR: Student {0} does not exist.'.format(student_name))            self.undo_stack.push(1)        # If the course doesn't exist yet, it must be made.        elif not c_exists:            self.new_class_creation(student, course_name)            self.undo_stack.push(('enrol', student_name, course_name))        # The consequent elif + else are only if student exists + course exists        elif len(course.student_list) >= 30:            self.undo_stack.push(1)            print ('ERROR: Course {0} is full.'.format(student.name))        elif course_name in student.course_list:            self.undo_stack.push(1)        # When course and student exist, and course <30        else:            student.enrol_class(course)            course.student_addition(student.name)            self.undo_stack.push(('enrol', student_name, course_name))    def new_class_creation(self, student, course_name):        new_class = Course(course_name, student.name)        self.course_list.append(new_class)        student.enrol_class(new_class)    def class_list(self, course_name):        self.undo_stack.push(1)        course_exists, course = object_caller(course_name, self.course_list)        if course_exists:            course.class_list()        else:            # course does not exist.  But we say this anyway...            print ('No one is taking ' + course_name + '.')    def undo_once(self):        try:            undo_variable = self.undo_stack.pop()            if type(undo_variable) == tuple:                self.undo_it(undo_variable)        except EmptyStackError:            print ('ERROR: No commands to undo.')    def undo_it(self, undo_tuple):        if undo_tuple[0] == 'create':            name = undo_tuple[1]            poor_student = object_caller(name, self.student_list)[1]            self.student_list.remove(poor_student)        elif undo_tuple[0] == 'enrol':            name, course = undo_tuple[1], undo_tuple[2]            target_student = object_caller(name, self.student_list)[1]            target_course = object_caller(course, self.course_list)[1]            target_student.course_drop(course)            target_course.student_removal(name)        elif undo_tuple[0] == 'drop':            student_name, course_name = undo_tuple[1], undo_tuple[2]            student = object_caller(student_name, self.student_list)[1]            course = object_caller(course_name, self.course_list)[1]            student.enrol_class(course)            course.student_addition(student.name)        else:            print ("Something went horribly wrong.")    def undo_repeat(self, repeats):        if natural_number_checker(repeats):            repeats = int(repeats)            for x in range(0, repeats):                try:                    undo_variable = self.undo_stack.pop()                    if type(undo_variable) == tuple:                        self.undo_it(undo_variable)                except EmptyStackError:                    print ("ERROR: No commands to undo.")                    break        else:            print ("ERROR:", repeats, "is not a positive natural number.")            self.undo_stack.push(1)
class Student:
    def __init__(self, name):
        self.name = name
        self.course_list = []    def course_drop(self, course):        self.course_list.remove(course)    def common_check(self, other_student):        common_list = []        for course in self.course_list:            if course in other_student.course_list:                common_list.append(course)        if len(common_list) >= 1:            common_list.sort()            print (', '.join(common_list))        else:            print ()    def list_courses(self):        self.course_list.sort()        printstr = ', '.join(self.course_list)        print ('{0} is taking {1}'.format((self.name), printstr))             def enrol_class(self, target_class):        self.course_list.append(target_class.name)
class Course:    def __init__(self, name, student):
        self.name = name
        self.student_list = [student]    def student_removal(self, student_name):        self.student_list.remove(student_name)    def student_addition(self, student_name):        self.student_list.append(student_name)    def class_list(self):        if len(self.student_list) == 0:            print('No one is taking {0}.'.format(self.name))        else:            self.student_list.sort()            print (', '.join(self.student_list))# HELPER FUNCTIONS
def object_caller(name, target_list):
    for object in target_list:
        if object.name == name:
            return True, object
    return False, Nonedef natural_number_checker(number):    try:        int_number = int(number)        if int_number > 0:            return True    # only occurs if not integer.    except (ValueError, TypeError) as e:        return False