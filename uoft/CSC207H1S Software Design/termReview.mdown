#CSC207 midterm review notes

- subversion
	- basic commands (`update, add, commit, checkout, status, list`)

- Java
	- all topics covered, except Java's exceptions
	- memory model

- Objective-oriented design
	- basic UML class diagrams (A1)
	- Java features, such as *encapsulation, polymorphism, interfaces,* and *abstract classes*.

#week1 lec1

##Version Control

two flavors: centralized (e.g., SVN, CSV), distributed (e.g., Git, Mercurial)

**repository**: "master copy", never directly modify this! When local copy changes, "commit" the changes to the repository.

#week1 lec2

##Subversion
Version control systems store incremental differences. The incremental differences allow the system to reconstruct previous versions.

###some common commands

	svn checkout [url]

Get initial copy.

Do this anywhere to get a local copy of a repo.

	svn add [filenames]

Add new files. 

Notifies Subversion that you want it to track the new files. Add will almost always be followed by a commit because add doesn't actually modify the repository.

	svn status [filenames]

See what's changed.

	svn update [filenames]

Synchronize with repository.

Copies from the master repo to your local copy. Any commits made by another person or commits done by you from another local copy will be updated in your local copy. Does not change the repo. Watch the messages closely.

	svn commit [filenames]

Commit local changes.

Copy changes to the repo. Will only be allowed if the local copy is up to date.

	svn remove [filenames]

Remove files from repository.

Must first remove the file from the local copy. It is not easy to remove directories. Need to commit, just like for add.

	svn diff [filenames]

Show diffs between local & repo.

Handy to see what changed between versions.

	svn log [filenames]

Show history of files.

Show log message, timestamps and who made the revisions.

#week2 lab1

`setenv SVN_EDITOR nedit` make `nedit` your editor. 

`nedit` *file* edit file named *file* using editor `nedit`

`cat` *file* show the content of the file *file*

`svn delete URL/PATH` - delete an item from a working copy or the repository.

`svn commit -m 'the log message'` - specify the log message that will be associated with the current commit.

#week2 lec3

##UNIX and Subversion Tips

###common pitfalls

"not a working copy" - issuing `svn add` on a file from a directory that is not part of the local copy

"not under version control" - issuing `svn commit` on a file that is not part of the local copy

"skipped path" - issuing `svn update` on a directory that is not part of the local copy

`svn add` and `svn commit` are recursive; for non-recursive use, add a flag `-N` as `svn -N add newDir`.

###compilation - introducing Java

Two flavors of translation: **interpretation** and **compilation**.

interpreted, e.g., *Python*, translate and execute one statement at a time.

complied, e.g., *C*, translate the entire program (once), then execute (any number of times)

hybrid, e.g., *Java*, translate to something intermediate (in Java, bytecode)

###3 types of comments in Java.

*Uno.*

	// Comments:
	// Put your comments above the code they are
	// commenting on.

*Dos.*

	/*
	 * This is a multi-line
	 * comment.
	 * It can span multiple lines.
	 */

*Tres.*

	/**
	 * This is a Javadoc comment. (Similar to Python's docstring.)
	 * Prints hello world.
	 * @param args Command Line arguments.
	 */

#week2 lec4

##python vs. java notes

|Python|Java|
|:-|:-|
|a statement is a program|a statement is NOT a program, need a class, need a main method|
|values have types, variables do not have types, they are just names|variables have types|
|fully oo, 3 is an object, it has methods|primitive types, objects (have methods, etc.), wrapper classes for primitive types (e.g., Integer for int)|

##Types
Every variable has a type: **primitive** or **class** types.

###primitive types
- primitive types are not objects: int, boolean, char, double, byte, short, long, float
- names begin with lowercase letters.
- can declare a variable; cannot redeclare it. But we can 'reassign' its value.
- double quotation mark for *strings*.
- single quotation mark for *characters*.

###class types
- declare variable named myInteger. Create a new object of type Integer, which contains among other things the int value 10; assign the reference to the newly created object to variable myInteger.

`Integer myInteger = new Integer(10);`

`// with (previously) int x = 8;`
`Integer xInteger = new Integer(x);`

if we print myInteger, we will get 10 and 8.

###String
- Strings are objects, immutable.

###Indexing
`char letter = s2.charAt(3);`

###Slicing
`String slice = s2.substring(4); // Python: s2[4:]`

`s2.substring(5, 7); // Python: s2[5:7]`

###Stripping (remove whitespace from beginning and end of String.)

`"      hi there     "` becomes `"hi there"`

###Splitting
	s3 = "before    hi   there   after";
    String[] parts = s3.split("e");
    System.out.println(parts[0]);
    System.out.println(parts[1]);
    System.out.println(parts[2]);

we will get:

`b`

`for`

`    hi   th`

###Arrays

- not like Python lists:
	- fixed length, which is set when constructing the object
	- all elements must have the same type

	int[] intArray = new int[4];
    System.out.println(intArray[0]); // this array is full of 0 in fact

    String[] stringArray = new String[20];
    System.out.println(stringArray[0]); // this array is full of null
    stringArray[0] = "hello";
    System.out.println(stringArray[0]); // set index 0 item to be something meaningful

    intArray = new int[] {1, 2, 3};
    System.out.println(intArray[1]); // can reassign variable

    System.out.println(intArray); // this actually prints nothing but the memory address of intArray


#week2 readings

##closer look at hello world

`public static void main(String[] args) {` begins the definition of the main method.

- every application must contain a `main` method whos signature is: `public static void main(String[] args)`.
- the **modifiers** `public` and `static` can be written in either order
- `args` and `argv` both work

##Java
Buzzwords of Java: *Simple, Object oriented, Distributed, Multithreaded, Dynamic, Architecture neutral, Portable, High performance, Robust, Secure*.

**bytecodes** - the machine language of the Java Virtual Machine (Java VM)

#week3 lab2

practice svn and some types in Java.

#week3 lec5

##Java OO

###Instance variables

	public class Circle {
		private String radius;
	}

	`radius` **is an instance variable**. Each object/instance of the class Circle has its own radius variable.

###Constructors

A **constructor** has:

- the same name as the class
- no return type (not even `void`)

A class can have multiple constructors.

###`this`
`this` is an instance variable that we get without declaring it. Like `self` in Python.

###defining methods
- a **method** must have a return type declared. use `void` if nothing is returned.
- `return expression;` if the expression is omitted or if the end of the method is reached without executing a return statement, nothing is returned.
- specify the accessibility.
- variable declared in a method are local to that method.

###parameters
- aliasing!

###Encapsulation
*Convention*: make all non-final instance variables `private`, which makes them accessibe only within the class, or protected, which makes them accessible only within the package. When desired, give outside access using *getter* and *setter* methods.

###access modifiers

|modifier|class|package|subclass|world|
|:-|:-|:-|:-|:-|
|`public`|Y|Y|Y|Y
|`protected`|Y|Y|Y|N|
|no modifier (package-private)|Y|Y|N|N|
|`private`|Y|N|N|N|

##MoreTypes.java

###Basic for loop
Three parts (similar to while loop):
- initialization: int i = 0;
- loop condition; i < integers.length;
- increment: i++;

	for (int i = 0; i < integers.length; i++) {
		System.out.println(integers[i]);
	}

###Enhanced for loop
	for (int item : integers) {
		System.out.println(item);
	}

###Autoboxing and its behavior

use `Integer y = 2;` instead of `Integer y = new Integer(2);`

This is called **autoboxing**: automatically putting a primitive type 2 into a "box" -- an object of type Integer.

can be done with any *primitive type* and its *wrapper class*.

**unboxing**:

	Double d1 = new Double(3.14);
	double d2 = d1

**Aliasing**:

	Double d3 = d1; // d3 and d1 refer to the same object

Notice that:

	Integer i1 = new Integer (7);
	Integer i2 = new Integer (7);
	int i3 = 7;
	System.out.println(i1 == i2); // false, two different objects
	System.out.println(i1 == i3); // true
	System.out.println(i2 == i3); // true
	System.out.println(i1.equals(i2)); true, rather than comparing the memory address, we can compare the int value that the Integer objects are boxing.

##Main.java
before we added our own constructor, Java provided a default constructor that takes no arguments. Once we declared our own constructor, the default one is no longer available.

Person's instance variable `dob` is private in Person class, so it cannot be accessed outside Person class; instead, we create a public "getter" method to get the `dob` instance variable's value.

if we directly call `System.out.println(jen);` we will get the memory address, because Person originally inherited `toString()` method from Object; we then need to define `toString` in the Person class (**overriding** the `toString` method from Object.

##Person.java

#week3 lec6

##Memory Model Exercise

##More Java OO
###Inheritance hierarchy
*Object* at the root. Class *Object* does not have a parent. All other Java classes have one parent. If a class has no parent declared, it is a child of class *Ojbect*. A parent class can have multiple child classes. Class *Object* guarantees that every class inherits methods `toString, equals,` and others.

###Inheritance
In a subclass, `super` refers to the part of the object defined by the paretn class.

###Shadowing and Overriding
class `A` and its subclass `AChild` each have an instance variable `x` and an instance method `m`

`A`'s `x` is **shadowed** by `AChild`'s `x`. -- This is confusing and not a good idea.

`A`'s `m` is **overridden** by `AChild`'s `m`. -- Often a good idea. we often want to specialize behavior in a subclass.

If a method must not be overridden in a descendant, declare it `final`.

###Dynamic Binding
A variable can be assigned objects of its type or any subtype.

###Casting Down
`Object o = new String("hello");`

cannot do the following: `char c = o.charAt(1);` because `Object` does not have a `charAt` method

but we can do `char c = ((String) o).charAt(1);` instead.

We cast the object that `o` refers to as a `String`.

##Main(aliasing, overriding, shadowing).java

Student is a subclass of Person.

	System.out.println((Person) bob).example); // prints the example variable from class Person.
	System.out.println((Person) bob).toString()); // calls toString() from Student!

#week3 readings
##Class Tutorial

#week4 lab3

Arthur.java and Book.java

#week4 lec7
##uml oo design
**UML** -- Unified Modeling Language. (we only use a part of it -- *class diagram* to represent basic oo design)

###notation
####data members:
`name: type`
####methods:
`methodName(param1: type1, param2: type2,...): returnType`
####Visibility:
	- private
	+ public
	# protected
	~ package
####Static:
	underline(this part is underlined)
####Abstract
Abstract method: *italic*

Abstract class: *italic* or <<abstract>>

Interface: <<interface>>

Relationship between classes: Inheritance is 实arrow; Interface is 虚arrow

##Main(shadowing, overriding, polymorphism, static).java

`instanceof`: `bob instanceof Student` is true

**shadowing**: avoid doing this! (child and parent classes have two instance variables with the same type.)

if we treat `bob` as a `Person`, can only call `Person` methods instead of `Student` methods. but for `toString` method, it is overriden in `Student`, so `System.out.println(((Person) bob).toString());` calls `toString` from `Student` in fact.

**Polymorphism**: one object having multiple forms.

	System.out.println("The people are: ");
	for (Person person: people) {
		System.out.println(person); // polymorphism!
	}

##Student(static variable, static method).java

**Static** modifier: can access the static variable (here in example, which counts students) before a Student instances exist.

static members belong to the class instead of a specific instance.

It means that only one instance of a static field exists even if you create a million instances of the class or you don't create any. It will be shared by all instances.

Since static methods also do not belong to a specific instance, they can't refer to instance members. static members can only refer to static members. Instance members can, of course access static members.

Side note: Of course, static members can access instance members through an object reference.

##Grade(abstract class, abstract method, static method).java

an **abstract class**:

- cannot be instantiated, but can be subclassed;
- it can, but is not required to, contain abstract methods

an **abstract method** is one that is declared without an implementation.

If a class contains an abstract method, then the class must be abstract. 

##LetterGrade.java
##NumericGrade.java

###`switch` statement (unlike if-then or if-else, switch could have a number of possible execution paths).

	switch (grade) {
    case "A": gpa_value = 4.0; break;
    case "B": gpa_value = 3.0; break;
    case "C": gpa_value = 2.0; break;
    case "D": gpa_value = 1.0; break;
    case "F": gpa_value = 0.0;
    }

#week4 lec8

##Main(abstract class, 2d arrays, generics, collections, list, map).java
###2D array

	// A 3 x 4 array.
	int[][] table = new int[3][4];

	// An array with 3 rows and columns of length 4, 2, and 3, 
    // respectively.
    // When column length varies, sometimes called "jagged" or
    // "ragged" array.
    int[][] jagged = new int[3][];
    jagged[0] = new int[4];
    jagged[1] = new int[2];
    jagged[2] = new int[3];    

###abstract class
1. abstract class does not have instantiation!
2. abstract method: subclasses of abstract class must implement it

###collections
- Java Collections: Map, List, Set, Queue, etc (these are all interfaces)

- List is very similar to Python's lists.
- declare and initialize an ArrayList of Strings.
- Lists are generic, so we provide the type of the elements.

	List<String> csc207team = new ArrayList<String>();

- can only add String types into the List.

###generics
generics must use object types

Can have an ArrayList of any valid (built-in or user-defined) Java object type (i.e. no primitives!)

`List<int> primitiveIntList` is wrong! should be `List<Integer> intList = new ArrayList<Integer>();` instead!

but we can autobox and autounbox primitive types: `intList.add(12)`;

##Map
Map interface is similar to Python's dictionary type.

collection of unordered (key, value) paris.

	Map<String, Integer> myMap = new HashMap<String, Integer>();

##IDed(interface, generic).java

Interface cannot be instantiated. all methods in an interface are abstract.	
an interface cannot have instance variables (Can only have public static final variables) a class may implements multiple interfaces.

<T> type, <E> element.

#week4 readings
##javadoc
##interfaces

#week5 lab4

#week5 lec9

##ooDesignConcepts(stack, heap, memory, generics, abstract classes, interfaces)
###memory
Data is stored in two areas of memory: the *(call) stack* and the *heap*.

**call stack**: keep tracks of method calls including parameter values, local variables, and return addresses.

**heap**: store objects. variables reference the objects stored in the heap.

unusued object will go to garbage collector

###recap
- generics: allow types to be parameters to classes, interfaces and methods.

- generic code vs. nongeneric code

- abstract class: may contain instance and static (class) variables. may contain abstract methods. may contain implemented methods. cannot be instantiated.

- interface: may contain only `public static final` variables.

- **APIs**: Application Programming Interface

##Main(generics, queues, using generic class).java

##Grade(compareTo class, overriding).java

##WaitList(generic class).java

#week5 lec10

##Main(equals, compareTo).java

- identity equality: `s1 == s2`

- value equality: `s1.equals(s2)`

- compareTo
	
	Double d1 = new Double(2.5);
	Double d2 = new Double(4.2);
	Double d3 = new Double(4.2);

	System.out.println(d1.compareTo(d2)); // -1
	System.out.println(d2.compareTo(d1)); // 1
	System.out.println(d2.compareTo(d3)); // 0

##Course(using WaitList, lots of OOP topics).java

#week6 lab5

